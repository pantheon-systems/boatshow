<?php

use Drupal\Core\Access;
use Drupal\Core\Access\AccessResult;
use Drupal\Core\Session\AccountInterface;
use Drupal\node\Entity\Node;
use Drupal\Core\Access\AccessResultInterface;
use Drupal\Core\Entity\EntityListBuilder;
use Drupal\Core\Entity\ContentEntityForm;

use Drupal\node\NodeInterface;
/**
 * @file
 * Contains Drupal\nmmacontentaccess\nmmacontentaccess.module.
 */

/**
 * @defgroup nmmacontentaccess Example: nmmacontentaccess node
 * @ingroup examples
 * @{
 * Implement a content entity.
 *
 * This module demonstrates implementing a nmmacontentaccess node.
 *
 * Entity API is the API that stores pieces of content and configuration for
 * Drupal core. For instance, if you've encountered node content types, you've
 * encountered entities of type 'node.'
 *
 * This example implements the Entity API so that we have an entity type usable
 * by the user which you might think of as specialized nodes, but which are
 * different from nodes. These entities are called NmmaNode, and are known
 * internally by the machine name nmmacontentaccess_node.
 *
 * NmmaNode is a fieldable content entity used to hold structured information
 * without the overhead of using a node content type. 'Fieldable' means you can
 * attach fields to it, like you can with nodes. It is defined programmatically
 * (completely in code). We will show the main techniques to handle and expose
 * the contents of this entity type.
 *
 * The NmmaNode entity will demonstrate the main tasks for an entity:
 * - define
 * - save
 * - load
 * - view
 * - edit
 * - delete
 * - control access
 *
 * Where ever possible, we use the amazing tools built into D8 natively.
 *
 * @see Drupal\nmmacontentaccess\Entity\NmmaNode
 * @see config_entity_example
 * }
 */

 /**
 * Implements hook_node_access().
 *
 * Enforces our access rules for custom workflow target content to force updates
 * only if the user is targeted in the user select field
 */
 function nmmacontentaccess_node_access($node, $op, $account) {
   // If a node is being updated

   $allowedRoles = \Drupal::entityManager()
         ->getStorage('nmmacontentaccess_node')
         ->loadByProperties(['node_id' => $node->id()]);
   $access = AccessResult::neutral();
   if (!empty($allowedRoles)) {
     // \Drupal::logger('nmmacontentaccess')->notice("there are allowed roles");
     $allowedRoles = array_shift($allowedRoles);
     $allowedRoles = $allowedRoles->get('roles')->getValue();
     $result=array_intersect(array_column($allowedRoles, 'target_id'),$account->getRoles());
     // var_dump($allowedRoles);
     // var_dump($account->getRoles());
     // var_dump($result);
     // var_dump($op);
     // var_dump($node->id());
     if (($op == 'update' || $op == 'delete') && empty($result))  {
       // If the user select field exists on this node
          //\Drupal::logger('nmmacontentaccess')->notice("setting access to forbidden");
             //drupal_set_message('this is the opt:' . $op);
             //drupal_set_message(t('Your user role has not been given access to this node.'));
             $access = AccessResult::forbidden();
     }
   }
   // Else ignore altering access
           return $access;
}
